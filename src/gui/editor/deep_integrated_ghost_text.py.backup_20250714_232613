"""
æ·±åº¦é›†æˆQTextDocumentçš„Ghost Textç³»ç»Ÿ
å®ç°å®Œç¾çš„é¢„è§ˆæ•ˆæœï¼Œä¸å®é™…æ’å…¥æ•ˆæœå®Œå…¨ä¸€è‡´
"""

import logging
import time
from typing import Optional, Dict, Set, List, Tuple
from PyQt6.QtWidgets import QTextEdit, QWidget
from PyQt6.QtCore import Qt, QTimer, QRectF, QPointF, QObject, pyqtSignal
from PyQt6.QtGui import (
    QTextDocument, QTextCursor, QTextBlock, QTextBlockUserData,
    QTextCharFormat, QTextLayout, QColor, QPainter, QFont,
    QFontMetrics, QKeyEvent, QPaintEvent
)

logger = logging.getLogger(__name__)


class GhostTextUserData(QTextBlockUserData):
    """å­˜å‚¨Ghost Textç›¸å…³æ•°æ®çš„ç”¨æˆ·æ•°æ®ç±»"""
    
    def __init__(self):
        super().__init__()
        self.ghost_text = ""
        self.ghost_position = 0  # åœ¨å—ä¸­çš„ç›¸å¯¹ä½ç½®
        self.is_active = False
        self.timestamp = time.time()  # ç”¨äºè¿‡æœŸæ£€æŸ¥
        self.original_format = None  # ä¿å­˜åŸå§‹æ ¼å¼ç”¨äºæ¢å¤


class PreciseLayoutCalculator:
    """ç²¾ç¡®å¸ƒå±€è®¡ç®—å™¨ - åŸºäºQTextLayoutçš„åŸç”Ÿå¸ƒå±€å¼•æ“"""
    
    def __init__(self, document: QTextDocument):
        self.document = document
        
    def calculate_ghost_position(self, block: QTextBlock, position_in_block: int) -> QRectF:
        """ä½¿ç”¨QtåŸç”Ÿå¸ƒå±€å¼•æ“è®¡ç®—ç²¾ç¡®çš„Ghost Textä½ç½®"""
        if not block.isValid():
            return QRectF()
            
        layout = block.layout()
        if not layout:
            return QRectF()
            
        # éªŒè¯ä½ç½®åœ¨å—èŒƒå›´å†…
        if position_in_block < 0 or position_in_block > block.length():
            return QRectF()
            
        # è·å–å…‰æ ‡åœ¨å½“å‰è¡Œçš„ä½ç½®
        line = layout.lineForTextPosition(position_in_block)
        if not line.isValid():
            return QRectF()
            
        try:
            # è®¡ç®—ç²¾ç¡®çš„xåæ ‡ - å®‰å…¨å¤„ç†å¯èƒ½çš„tupleè¿”å›å€¼
            cursor_x_raw = line.cursorToX(position_in_block)
            cursor_x = float(cursor_x_raw[0]) if isinstance(cursor_x_raw, (tuple, list)) else float(cursor_x_raw)
            
            # è·å–å—åœ¨æ–‡æ¡£ä¸­çš„ä½ç½®
            doc_layout = self.document.documentLayout()
            if not doc_layout:
                return QRectF()
            
            # ç¡®ä¿å¸ƒå±€æ˜¯æœ€æ–°çš„
            # è¿™ä¼šå¼ºåˆ¶Qtæ›´æ–°æ–‡æ¡£å¸ƒå±€
            doc_layout.documentSize()
                
            block_rect = doc_layout.blockBoundingRect(block)
            
            # å¦‚æœå—è¿˜æ²¡æœ‰å¸ƒå±€ä¿¡æ¯ï¼Œå°è¯•ä½¿ç”¨æ›¿ä»£æ–¹æ³•
            if block_rect.isNull() or (block_rect.y() == 0 and block.blockNumber() > 0):
                # å°è¯•é€šè¿‡è¿­ä»£å‰é¢çš„å—æ¥è®¡ç®—ä½ç½®
                estimated_y = 0.0
                current_block = self.document.firstBlock()
                while current_block.isValid() and current_block.blockNumber() < block.blockNumber():
                    current_rect = doc_layout.blockBoundingRect(current_block)
                    if not current_rect.isNull():
                        estimated_y = current_rect.y() + current_rect.height()
                    current_block = current_block.next()
                
                if estimated_y > 0:
                    logger.debug(f"Using estimated y position for block #{block.blockNumber()}: {estimated_y}")
                    # åˆ›å»ºä¸€ä¸ªä¼°ç®—çš„çŸ©å½¢
                    block_rect = QRectF(block_rect.x(), estimated_y, block_rect.width(), block_rect.height())
            
            # å®‰å…¨è·å–lineçš„ä½ç½®å’Œå°ºå¯¸ä¿¡æ¯
            line_y = float(line.y())
            line_height = float(line.height())
            block_y = float(block_rect.y())
            
            # æ·»åŠ è°ƒè¯•æ—¥å¿—
            logger.debug(f"Block #{block.blockNumber()}: block_rect={block_rect}, block_y={block_y}, line_y={line_y}, line_height={line_height}")
            
            # æ£€æŸ¥blockçš„æœ‰æ•ˆæ€§å’Œå¸ƒå±€çŠ¶æ€
            if block_y == 0 and block.blockNumber() > 0:
                logger.warning(f"Block #{block.blockNumber()} has y=0, this might be a layout issue. Block text: '{block.text()[:50]}...'")
            
            # è®¡ç®—æœ€ç»ˆåæ ‡ï¼Œç¡®ä¿å€¼æœ‰æ•ˆ - ä½¿ç”¨æ˜¾å¼çš„floatå‚æ•°
            ghost_rect = QRectF(
                max(0.0, cursor_x),
                max(0.0, block_y + line_y),
                0.0,  # å®½åº¦å°†åœ¨æ¸²æŸ“æ—¶è®¡ç®—
                max(1.0, line_height)  # ç¡®ä¿æœ€å°é«˜åº¦
            )
            
        except (TypeError, ValueError, AttributeError) as e:
            logger.warning(f"è®¡ç®—Ghost Textä½ç½®æ—¶å‡ºé”™: {e}")
            return QRectF()
        
        return ghost_rect
        
    def calculate_text_width(self, text: str, font: QFont) -> float:
        """è®¡ç®—æ–‡æœ¬å®½åº¦ï¼Œè€ƒè™‘ä¸­è‹±æ–‡æ··åˆ"""
        font_metrics = QFontMetrics(font)
        return font_metrics.horizontalAdvance(text)
        
    def get_line_available_width(self, block: QTextBlock, position_in_block: int, 
                                text_edit_width: int) -> float:
        """è·å–å½“å‰è¡Œçš„å¯ç”¨å®½åº¦"""
        layout = block.layout()
        if not layout:
            return float(text_edit_width)
            
        line = layout.lineForTextPosition(position_in_block)
        if not line.isValid():
            return float(text_edit_width)
        
        try:
            # å®‰å…¨è·å–cursor_xï¼Œå¤„ç†å¯èƒ½çš„tupleè¿”å›å€¼
            cursor_x_raw = line.cursorToX(position_in_block)
            cursor_x = float(cursor_x_raw[0]) if isinstance(cursor_x_raw, (tuple, list)) else float(cursor_x_raw)
            
            available = float(text_edit_width) - cursor_x
            return max(0.0, available)  # ç¡®ä¿ä¸è¿”å›è´Ÿæ•°
            
        except (TypeError, ValueError, AttributeError) as e:
            logger.warning(f"è®¡ç®—è¡Œå¯ç”¨å®½åº¦æ—¶å‡ºé”™: {e}")
            return float(text_edit_width)


class SmartRenderingEngine:
    """æ™ºèƒ½æ¸²æŸ“å¼•æ“ - éç ´åæ€§ä¸´æ—¶æ ¼å¼åŒ–"""
    
    def __init__(self, text_editor):
        self.text_editor = text_editor
        self.document = text_editor.document()
        self._ghost_format = self._create_ghost_format()
        
    def _create_ghost_format(self) -> QTextCharFormat:
        """åˆ›å»ºGhost Textä¸“ç”¨æ ¼å¼"""
        ghost_format = QTextCharFormat()
        # æ ¹æ®ä¸»é¢˜è®¾ç½®é€‚å½“çš„é¢œè‰²
        if hasattr(self.text_editor, 'palette'):
            base_color = self.text_editor.palette().text().color()
            if base_color.lightness() > 128:  # æµ…è‰²ä¸»é¢˜
                ghost_color = QColor(100, 100, 100, 200)  # æ·±ç°è‰²ï¼Œæ›´ä¸é€æ˜
            else:  # æ·±è‰²ä¸»é¢˜
                ghost_color = QColor(160, 160, 160, 220)  # äº®ç°è‰²ï¼Œæ›´ä¸é€æ˜
        else:
            ghost_color = QColor(128, 128, 128, 200)  # é»˜è®¤é¢œè‰²
        ghost_format.setForeground(ghost_color)
        # ä¿®å¤PyQt6 APIå…¼å®¹æ€§
        try:
            ghost_format.setProperty(QTextCharFormat.Property.UserProperty + 1, "ghost_text")
        except AttributeError:
            # å¦‚æœæ–°APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ
            logger.warning("QTextCharFormat.Property.UserProperty not available, skipping property setting")
        return ghost_format
        
    def render_ghost_text_at_position(self, painter: QPainter, text: str, 
                                    position: QRectF, font: QFont):
        """åœ¨æŒ‡å®šä½ç½®æ¸²æŸ“Ghost Text"""
        if not text or not position.isValid():
            return
            
        # åˆ›å»ºä¸´æ—¶å¸ƒå±€
        temp_layout = QTextLayout(text, font)
        temp_layout.beginLayout()
        
        try:
            line = temp_layout.createLine()
            if line.isValid():
                line.setPosition(QPointF(0, 0))  # è®¾ç½®ç›¸å¯¹ä½ç½®
                
                temp_layout.endLayout()
                
                # è®¾ç½®ç»˜åˆ¶é¢œè‰² - æ ¹æ®ä¸»é¢˜è°ƒæ•´ï¼Œä½¿ç”¨åŠé€æ˜æ•ˆæœ
                if hasattr(self.text_editor, 'palette'):
                    base_color = self.text_editor.palette().text().color()
                    if base_color.lightness() > 128:  # æµ…è‰²ä¸»é¢˜
                        ghost_color = QColor(80, 80, 80, 150)  # æ›´æ·±çš„é¢œè‰²ï¼ŒåŠé€æ˜
                    else:  # æ·±è‰²ä¸»é¢˜
                        ghost_color = QColor(180, 180, 180, 150)  # æ›´äº®çš„é¢œè‰²ï¼ŒåŠé€æ˜
                else:
                    ghost_color = QColor(128, 128, 128, 150)  # é»˜è®¤åŠé€æ˜
                painter.setPen(ghost_color)
                
                # æ¸²æŸ“æ–‡æœ¬åˆ°æŒ‡å®šä½ç½® - ç¡®ä¿ä½ç½®å‚æ•°ç±»å‹æ­£ç¡®
                top_left = position.topLeft()
                if isinstance(top_left, QPointF):
                    temp_layout.draw(painter, top_left)
                else:
                    # å®‰å…¨å›é€€ï¼šåˆ›å»ºæ–°çš„QPointF
                    safe_position = QPointF(float(position.x()), float(position.y()))
                    temp_layout.draw(painter, safe_position)
            else:
                temp_layout.endLayout()
        except Exception as e:
            # ç¡®ä¿å¸ƒå±€è¢«æ­£ç¡®ç»“æŸ
            temp_layout.endLayout()
            logger.error(f"Ghost text rendering failed: {e}")
        
    def render_ghost_text_simple(self, painter: QPainter, text: str, 
                                position: QRectF, font: QFont):
        """ç®€åŒ–çš„ Ghost Text æ¸²æŸ“æ–¹æ³• - ä½¿ç”¨ drawText ç›´æ¥æ¸²æŸ“"""
        if not text or not position.isValid():
            return
            
        try:
            # ä¿å­˜ç”»ç¬”çŠ¶æ€
            painter.save()
            
            # è®¾ç½®å­—ä½“
            painter.setFont(font)
            
            # è®¾ç½®ç»˜åˆ¶é¢œè‰² - æ ¹æ®ä¸»é¢˜è°ƒæ•´ï¼Œä½¿ç”¨æ›´æ˜æ˜¾çš„é¢œè‰²
            if hasattr(self.text_editor, 'palette'):
                base_color = self.text_editor.palette().text().color()
                if base_color.lightness() > 128:  # æµ…è‰²ä¸»é¢˜
                    ghost_color = QColor(100, 100, 100, 200)  # æ›´æ·±çš„é¢œè‰²ï¼Œæ›´ä¸é€æ˜
                else:  # æ·±è‰²ä¸»é¢˜
                    ghost_color = QColor(160, 160, 160, 200)  # æ›´äº®çš„é¢œè‰²ï¼Œæ›´ä¸é€æ˜
            else:
                ghost_color = QColor(128, 128, 128, 200)  # é»˜è®¤æ›´ä¸é€æ˜
            painter.setPen(ghost_color)
            
            # ä½¿ç”¨ drawText ç›´æ¥ç»˜åˆ¶
            # æ³¨æ„ï¼šposition å·²ç»æ˜¯ viewport åæ ‡ï¼Œä¸éœ€è¦é¢å¤–è½¬æ¢
            # Qt drawText ä½¿ç”¨åŸºçº¿å¯¹é½ï¼Œéœ€è¦è°ƒæ•´ y åæ ‡
            draw_x = position.x()
            # åŸºçº¿ä½ç½®ï¼šé¡¶éƒ¨ + å¤§çº¦ 80% çš„è¡Œé«˜
            # å¦‚æœ y æ˜¯ 0 ä¸”å—å·ä¸æ˜¯ 0ï¼Œä½¿ç”¨å…‰æ ‡ä½ç½®ä½œä¸ºå¤‡ç”¨
            if position.y() == 0:
                # å°è¯•è·å–æ›´å‡†ç¡®çš„ä½ç½®
                font_metrics = painter.fontMetrics()
                line_height = font_metrics.height()
                draw_y = line_height * 0.85  # è‡³å°‘æ˜¾ç¤ºåœ¨ç¬¬ä¸€è¡Œ
                logger.debug(f"Y is 0, using fallback position: {draw_y}")
            else:
                draw_y = position.y() + position.height() * 0.85
            
            # ç¡®ä¿åæ ‡åœ¨è§†å£èŒƒå›´å†… - å¢åŠ è°ƒè¯•ä¿¡æ¯
            viewport_rect = self.text_editor.viewport().rect()
            if draw_x < -50 or draw_x > viewport_rect.width() + 50 or draw_y < -50 or draw_y > viewport_rect.height() + 50:
                logger.warning(f"Ghost text position out of viewport: ({draw_x}, {draw_y}), viewport: {viewport_rect}")
                # ä¸è¦ç›´æ¥è¿”å›ï¼Œä»ç„¶å°è¯•ç»˜åˆ¶ï¼Œè®©Qtè£å‰ªå†³å®š
            else:
                logger.debug(f"Ghost text rendering at: ({draw_x}, {draw_y}), text: '{text[:20]}...'")
            
            painter.drawText(QPointF(draw_x, draw_y), text)
            
            # è°ƒè¯•ï¼šç»˜åˆ¶ä¸€ä¸ªå¯è§çš„çŸ©å½¢æ¡†æ¥æ ‡è®°ä½ç½®
            if logger.isEnabledFor(logging.DEBUG):
                painter.setPen(QColor(255, 0, 0, 100))  # çº¢è‰²åŠé€æ˜è¾¹æ¡†
                debug_rect = QRectF(position.x() - 2, position.y() - 2, 
                                  position.width() + 4, position.height() + 4)
                painter.drawRect(debug_rect)
                # ç»˜åˆ¶åå­—æ ‡è®°
                painter.drawLine(QPointF(draw_x - 5, draw_y), QPointF(draw_x + 5, draw_y))
                painter.drawLine(QPointF(draw_x, draw_y - 5), QPointF(draw_x, draw_y + 5))
            
            # æ¢å¤ç”»ç¬”çŠ¶æ€
            painter.restore()
            
            logger.debug(f"Simple ghost text rendered at ({draw_x}, {draw_y}): {text[:20]}...")
            
        except Exception as e:
            logger.error(f"Simple ghost text rendering failed: {e}")
            if painter:
                painter.restore()
        
    def wrap_text_to_width(self, text: str, available_width: float, 
                          font: QFont) -> List[str]:
        """æ™ºèƒ½æ–‡æœ¬æ¢è¡Œï¼Œå¤ç”¨ç¼–è¾‘å™¨çš„æ¢è¡Œé€»è¾‘"""
        if not text or available_width <= 0:
            return []
            
        try:
            font_metrics = QFontMetrics(font)
            lines = []
            remaining_text = text
            max_lines = 10  # é˜²æ­¢æ— é™å¾ªç¯
            line_count = 0
            
            while remaining_text and line_count < max_lines:
                # è®¡ç®—å½“å‰è¡Œèƒ½å®¹çº³çš„å­—ç¬¦æ•°
                line_text = ""
                for i, char in enumerate(remaining_text):
                    test_text = line_text + char
                    try:
                        text_width = font_metrics.horizontalAdvance(test_text)
                    except Exception:
                        # å¦‚æœå­—ä½“åº¦é‡å¤±è´¥ï¼Œä½¿ç”¨ä¼°ç®—å€¼
                        text_width = len(test_text) * 10
                        
                    if text_width > available_width:
                        break
                    line_text = test_text
                    
                if not line_text and remaining_text:
                    # å¦‚æœè¿ä¸€ä¸ªå­—ç¬¦éƒ½æ”¾ä¸ä¸‹ï¼Œè‡³å°‘æ”¾ä¸€ä¸ª
                    line_text = remaining_text[0]
                    
                lines.append(line_text)
                remaining_text = remaining_text[len(line_text):]
                line_count += 1
                
            return lines
        except Exception as e:
            logger.error(f"Text wrapping failed: {e}")
            return [text[:50] + "..." if len(text) > 50 else text]  # å…œåº•æ–¹æ¡ˆ


class SmartUpdateManager:
    """æ™ºèƒ½æ›´æ–°ç®¡ç†å™¨ - ä¼˜åŒ–æ€§èƒ½"""
    
    def __init__(self, parent=None):
        self._update_timer = QTimer(parent)
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._perform_update)
        self._pending_updates = set()
        self._update_callback = None
        
    def schedule_update(self, block_number: int, callback=None):
        """è°ƒåº¦æ›´æ–°ç‰¹å®šå—"""
        self._pending_updates.add(block_number)
        if callback:
            self._update_callback = callback
        self._update_timer.start(16)  # 60fpsæ›´æ–°é¢‘ç‡
        
    def _perform_update(self):
        """æ‰§è¡Œæ‰¹é‡æ›´æ–°"""
        if self._pending_updates and self._update_callback:
            self._update_callback(self._pending_updates.copy())
        self._pending_updates.clear()


class GhostTextEventHandler:
    """Ghost Textäº‹ä»¶å¤„ç†å™¨"""
    
    def __init__(self, ghost_text_manager):
        self.manager = ghost_text_manager
        
    def handle_key_press(self, event: QKeyEvent) -> bool:
        """å¤„ç†æŒ‰é”®äº‹ä»¶
        
        Returns:
            bool: True if event was handled, False otherwise
        """
        if not self.manager.has_active_ghost_text():
            return False
            
        # Tabé”®ï¼šæ¥å—Ghost Text
        if event.key() == Qt.Key.Key_Tab:
            return self.manager.accept_ghost_text()
            
        # ESCé”®ï¼šæ‹’ç»Ghost Text  
        elif event.key() == Qt.Key.Key_Escape:
            return self.manager.reject_ghost_text()
            
        # å­—ç¬¦è¾“å…¥ï¼šæ¸…ç†Ghost Text
        elif event.text() and event.text().isprintable():
            self.manager.clear_ghost_text()
            return False
            
        return False


class DeepIntegratedGhostText(QObject):
    """æ·±åº¦é›†æˆQTextDocumentçš„Ghost Textç®¡ç†å™¨
    
    æ ¸å¿ƒç‰¹æ€§ï¼š
    - åŸºäºQTextBlockUserDataçš„éç ´åæ€§å­˜å‚¨
    - ä½¿ç”¨QtåŸç”Ÿå¸ƒå±€å¼•æ“çš„ç²¾ç¡®ä½ç½®è®¡ç®—
    - æ™ºèƒ½æ¸²æŸ“ç¡®ä¿é¢„è§ˆä¸å®é™…æ•ˆæœä¸€è‡´
    """
    
    # ä¿¡å·
    ghost_text_changed = pyqtSignal(str)
    ghost_text_accepted = pyqtSignal(str)
    ghost_text_rejected = pyqtSignal()
    
    # å…¼å®¹æ€§ä¿¡å· - ç”¨äºæ›¿æ¢ ModernGhostTextCompletion
    completionAccepted = pyqtSignal(str)
    completionRejected = pyqtSignal()
    
    def __init__(self, text_editor):
        super().__init__(text_editor)
        
        self.text_editor = text_editor
        self.document = text_editor.document()
        
        # æ ¸å¿ƒç»„ä»¶
        self.layout_calculator = PreciseLayoutCalculator(self.document)
        self.rendering_engine = SmartRenderingEngine(text_editor)
        self.update_manager = SmartUpdateManager(self)  # ä¼ é€’parenté¿å…å†…å­˜æ³„æ¼
        self.event_handler = GhostTextEventHandler(self)
        
        # çŠ¶æ€ç®¡ç†
        self._ghost_blocks: Set[int] = set()  # åŒ…å«Ghost Textçš„å—å·
        self._active_ghost_data: Dict[int, GhostTextUserData] = {}
        self._current_ghost_position = -1
        self._current_ghost_text = ""
        
        # ç²¾ç®€æ—¥å¿—æ§åˆ¶ - é¿å…é‡å¤æ—¥å¿—åˆ·å±
        self._last_render_state = None
        self._render_fail_count = 0
        self._last_success_log = 0
        
        # è¿æ¥æ›´æ–°å›è°ƒ
        self.update_manager._update_callback = self._perform_block_updates
        
        # è¿æ¥ç¼–è¾‘å™¨äº‹ä»¶
        self._connect_editor_events()
        
    def _connect_editor_events(self):
        """è¿æ¥ç¼–è¾‘å™¨äº‹ä»¶"""
        # ç›‘å¬æ–‡æ¡£å˜åŒ–
        self.document.contentsChanged.connect(self._on_document_changed)
        
        # ç›‘å¬å…‰æ ‡å˜åŒ–
        self.text_editor.cursorPositionChanged.connect(self._on_cursor_changed)
        
    def show_ghost_text(self, text: str, position: int) -> bool:
        """æ˜¾ç¤ºGhost Text
        
        Args:
            text: Ghost Textå†…å®¹
            position: æ’å…¥ä½ç½®
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸæ˜¾ç¤º
        """
        if not text or position < 0:
            return False
            
        # æ¸…ç†ç°æœ‰çš„Ghost Text
        self.clear_ghost_text()
        
        # æ‰¾åˆ°ç›®æ ‡å—
        cursor = QTextCursor(self.document)
        cursor.setPosition(position)
        target_block = cursor.block()
        
        if not target_block.isValid():
            return False
            
        # åˆ›å»ºæˆ–è·å–ç”¨æˆ·æ•°æ®
        user_data = target_block.userData()
        if not user_data or not isinstance(user_data, GhostTextUserData):
            user_data = GhostTextUserData()
            target_block.setUserData(user_data)
            
        # è®¾ç½®Ghost Textæ•°æ®
        user_data.ghost_text = text
        user_data.ghost_position = position - target_block.position()
        user_data.is_active = True
        user_data.timestamp = time.time()
        
        # æ›´æ–°å†…éƒ¨çŠ¶æ€
        block_number = target_block.blockNumber()
        self._ghost_blocks.add(block_number)
        self._active_ghost_data[block_number] = user_data
        self._current_ghost_position = position
        self._current_ghost_text = text
        
        # è°ƒåº¦æ›´æ–°
        self.update_manager.schedule_update(block_number)
        
        # å‘å°„ä¿¡å·
        self.ghost_text_changed.emit(text)
        
        # è§¦å‘é‡ç»˜ - ä½¿ç”¨å¤šç§æ–¹å¼ç¡®ä¿æ›´æ–°
        self.text_editor.viewport().update()
        self.text_editor.update()  # ä¹Ÿæ›´æ–°ç¼–è¾‘å™¨æœ¬èº«
        
        # å¼ºåˆ¶ç«‹å³å¤„ç†äº‹ä»¶ä»¥ç¡®ä¿é‡ç»˜
        from PyQt6.QtWidgets import QApplication
        QApplication.processEvents()
        
        logger.info(f"ğŸ‘» æ˜¾ç¤ºGhost Text: '{text[:25]}...' (pos={position}, block={block_number})")
        return True
        
    def clear_ghost_text(self):
        """æ¸…ç†æ‰€æœ‰Ghost Text"""
        if not self._ghost_blocks:
            return
            
        # æ¸…ç†æ‰€æœ‰Ghost Textå—
        for block_number in self._ghost_blocks:
            block = self.document.findBlockByNumber(block_number)
            if block.isValid():
                user_data = block.userData()
                if user_data and isinstance(user_data, GhostTextUserData):
                    user_data.is_active = False
                    
        # æ¸…ç†å†…éƒ¨çŠ¶æ€
        self._ghost_blocks.clear()
        self._active_ghost_data.clear()
        self._current_ghost_position = -1
        self._current_ghost_text = ""
        
        # è§¦å‘é‡ç»˜
        self.text_editor.viewport().update()
        
        logger.debug("æ¸…ç†æ‰€æœ‰Ghost Text")
        
    def accept_ghost_text(self) -> bool:
        """æ¥å—å½“å‰çš„Ghost Text"""
        if not self.has_active_ghost_text():
            return False
            
        ghost_text = self._current_ghost_text
        position = self._current_ghost_position
        
        # æ¸…ç†Ghost TextçŠ¶æ€
        self.clear_ghost_text()
        
        # æ’å…¥å®é™…æ–‡æœ¬
        cursor = QTextCursor(self.document)
        cursor.setPosition(position)
        cursor.insertText(ghost_text)
        
        # å‘å°„ä¿¡å·
        self.ghost_text_accepted.emit(ghost_text)
        self.completionAccepted.emit(ghost_text)  # å…¼å®¹æ€§ä¿¡å·
        
        logger.debug(f"æ¥å—Ghost Text: '{ghost_text}'")
        return True
        
    def reject_ghost_text(self) -> bool:
        """æ‹’ç»å½“å‰çš„Ghost Text"""
        if not self.has_active_ghost_text():
            return False
            
        self.clear_ghost_text()
        self.ghost_text_rejected.emit()
        self.completionRejected.emit()  # å…¼å®¹æ€§ä¿¡å·
        
        logger.debug("æ‹’ç»Ghost Text")
        return True
        
    def has_active_ghost_text(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„Ghost Text"""
        result = bool(self._ghost_blocks and self._current_ghost_text)
        if not result and (self._ghost_blocks or self._current_ghost_text):
            logger.debug(f"Ghost text check: blocks={self._ghost_blocks}, text='{self._current_ghost_text[:20] if self._current_ghost_text else 'None'}'")
        return result
        
    def render_ghost_text(self, painter: QPainter):
        """åœ¨paintEventä¸­æ¸²æŸ“Ghost Text"""
        # æ£€æŸ¥åŸºæœ¬æ¡ä»¶
        has_active = self.has_active_ghost_text()
        painter_valid = painter and painter.isActive()
        
        # çŠ¶æ€æ£€æŸ¥ï¼šåªåœ¨çŠ¶æ€å˜åŒ–æ—¶è®°å½•
        current_state = (has_active, painter_valid, len(self._ghost_blocks))
        if current_state != self._last_render_state:
            logger.debug(f"ğŸ‘ï¸ Ghostæ¸²æŸ“çŠ¶æ€: active={has_active}, painter_ok={painter_valid}, blocks={len(self._ghost_blocks)}")
            self._last_render_state = current_state
        
        if not has_active or not painter_valid:
            return
            
        try:
            # æ¸²æŸ“æ‰€æœ‰æ´»è·ƒçš„Ghost Textå—
            rendered_count = 0
            for block_number in self._ghost_blocks:
                try:
                    block = self.document.findBlockByNumber(block_number)
                    if not block.isValid():
                        continue
                        
                    user_data = block.userData()
                    if not user_data or not isinstance(user_data, GhostTextUserData) or not user_data.is_active:
                        continue
                        
                    self._render_block_ghost_text(painter, block, user_data)
                    rendered_count += 1
                except Exception as e:
                    logger.error(f"Block {block_number} render failed: {e}")
                    continue
                    
            # åªåœ¨é¦–æ¬¡æˆåŠŸæˆ–å¤±è´¥æ—¶è®°å½•
            import time
            now = time.time()
            if rendered_count > 0:
                if now - self._last_success_log > 5:  # 5ç§’å†…æœ€å¤šè®°å½•ä¸€æ¬¡æˆåŠŸ
                    logger.info(f"âœ… Ghost Textæ¸²æŸ“: {rendered_count}ä¸ªå—")
                    self._last_success_log = now
                self._render_fail_count = 0
            elif self._render_fail_count == 0:
                logger.warning("âš ï¸ Ghost Textæ¸²æŸ“å¤±è´¥: æ— æœ‰æ•ˆå—")
                self._render_fail_count = 1
        except Exception as e:
            logger.error(f"Ghost text rendering failed: {e}")
            
    def _render_block_ghost_text(self, painter: QPainter, block: QTextBlock, 
                                user_data: GhostTextUserData):
        """æ¸²æŸ“å•ä¸ªå—çš„Ghost Text"""
        # è®¡ç®—ç²¾ç¡®ä½ç½®
        position = self.layout_calculator.calculate_ghost_position(
            block, user_data.ghost_position
        )
        
        # å¦‚æœä½ç½®è®¡ç®—å¤±è´¥æˆ–yä¸º0ï¼Œä½¿ç”¨ cursorRect ä½œä¸ºä¸»è¦æ–¹æ³•
        if position.isNull() or position.y() == 0:
            cursor = QTextCursor(self.document)
            cursor.setPosition(block.position() + user_data.ghost_position)
            cursor_rect = self.text_editor.cursorRect(cursor)
            if not cursor_rect.isNull():
                # ä½¿ç”¨ cursorRect çš„ä½ç½®ï¼Œæ›´å¯é 
                position = QRectF(cursor_rect)
                logger.debug(f"Using cursorRect for block {block.blockNumber()}: {position}")
            else:
                logger.warning(f"Both methods failed for block {block.blockNumber()}")
                return
        
        # å¦‚æœyåæ ‡ä¸º0ä¸”ä¸æ˜¯ç¬¬ä¸€ä¸ªå—ï¼Œå°è¯•ä½¿ç”¨å¤‡ç”¨æ–¹æ³•
        if position.y() == 0 and block.blockNumber() > 0:
            # ä½¿ç”¨QTextCursorè·å–æ›´å‡†ç¡®çš„ä½ç½®
            cursor = QTextCursor(block)
            cursor.setPosition(block.position() + user_data.ghost_position)
            cursor_rect = self.text_editor.cursorRect(cursor)
            if not cursor_rect.isNull() and cursor_rect.y() > 0:
                position = QRectF(cursor_rect)
                logger.debug(f"Using cursor rect as fallback for block {block.blockNumber()}: {position}")
        
        # è½¬æ¢åˆ°viewportåæ ‡ - ä½¿ç”¨translatedæ–¹æ³•æ­£ç¡®è½¬æ¢
        content_offset = self.text_editor.contentOffset()
        viewport_position = position.translated(content_offset)
        viewport_x = viewport_position.x()
        viewport_y = viewport_position.y()
        
        logger.debug(f"åæ ‡è½¬æ¢: doc_pos=({position.x()}, {position.y()}), content_offset=({content_offset.x()}, {content_offset.y()}), viewport=({viewport_x}, {viewport_y})")
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢è¡Œ
        available_width = self.layout_calculator.get_line_available_width(
            block, user_data.ghost_position, self.text_editor.width()
        )
        
        # æ™ºèƒ½æ¢è¡Œ
        lines = self.rendering_engine.wrap_text_to_width(
            user_data.ghost_text, available_width, self.text_editor.font()
        )
        
        # æ¸²æŸ“æ¯ä¸€è¡Œ
        try:
            line_height = float(position.height())
            # ä½¿ç”¨viewportåæ ‡
            pos_x = float(viewport_x)
            pos_y = float(viewport_y)
            
            for i, line_text in enumerate(lines):
                line_position = QRectF(
                    pos_x,
                    pos_y + i * line_height,
                    0.0,
                    line_height
                )
                
                # ä½¿ç”¨ç®€åŒ–çš„æ¸²æŸ“æ–¹æ³•ä»¥æé«˜å¯é æ€§
                self.rendering_engine.render_ghost_text_simple(
                    painter, line_text, line_position, self.text_editor.font()
                )
        except (TypeError, ValueError, AttributeError) as e:
            logger.warning(f"æ¸²æŸ“Ghost Textæ—¶å‡ºé”™: {e}")
            return
            
    def _perform_block_updates(self, block_numbers: Set[int]):
        """æ‰§è¡Œå—æ›´æ–°"""
        # è§¦å‘ç¼–è¾‘å™¨é‡ç»˜ç›¸å…³åŒºåŸŸ
        self.text_editor.viewport().update()
        
    def _on_document_changed(self):
        """æ–‡æ¡£å†…å®¹å˜åŒ–æ—¶çš„å¤„ç†"""
        # æ¸…ç†è¿‡æœŸçš„Ghost Text
        self._cleanup_expired_ghost_text()
        
    def _on_cursor_changed(self):
        """å…‰æ ‡ä½ç½®å˜åŒ–æ—¶çš„å¤„ç†"""
        # å¦‚æœå…‰æ ‡ç§»åŠ¨åˆ°Ghost TextåŒºåŸŸå¤–ï¼Œæ¸…ç†Ghost Text
        cursor = self.text_editor.textCursor()
        current_position = cursor.position()
        
        if self.has_active_ghost_text():
            # æ£€æŸ¥å…‰æ ‡æ˜¯å¦ä»åœ¨Ghost TextåŒºåŸŸ
            ghost_start = self._current_ghost_position
            ghost_end = ghost_start + len(self._current_ghost_text)
            
            if current_position < ghost_start or current_position > ghost_end:
                # å…‰æ ‡ç§»åŠ¨åˆ°Ghost TextåŒºåŸŸå¤–ï¼Œæ¸…ç†
                self.clear_ghost_text()
                
    def _cleanup_expired_ghost_text(self):
        """æ¸…ç†è¿‡æœŸçš„Ghost Textæ•°æ®"""
        current_time = time.time()
        expired_blocks = []
        
        for block_number, user_data in self._active_ghost_data.items():
            if current_time - user_data.timestamp > 30:  # 30ç§’è¿‡æœŸ
                expired_blocks.append(block_number)
                
        for block_number in expired_blocks:
            if block_number in self._ghost_blocks:
                self._ghost_blocks.discard(block_number)
            if block_number in self._active_ghost_data:
                del self._active_ghost_data[block_number]
                
        if expired_blocks:
            logger.debug(f"æ¸…ç†è¿‡æœŸGhost Textå—: {expired_blocks}")
    
    # ============ å…¼å®¹æ€§API - ç”¨äºæ›¿æ¢ ModernGhostTextCompletion ============
    
    def show_completion(self, suggestion: str) -> bool:
        """æ˜¾ç¤ºè¡¥å…¨å»ºè®® - å…¼å®¹API
        
        Args:
            suggestion: è¡¥å…¨å»ºè®®æ–‡æœ¬
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸæ˜¾ç¤º
        """
        if not suggestion or not suggestion.strip():
            return False
            
        cursor = self.text_editor.textCursor()
        cursor_pos = cursor.position()
        
        # è®¡ç®—å¢é‡è¡¥å…¨
        current_text = self.text_editor.toPlainText()
        completion = self._calculate_incremental_completion(current_text, cursor_pos, suggestion.strip())
        
        if not completion:
            return False
            
        return self.show_ghost_text(completion, cursor_pos)
    
    def hide_completion(self):
        """éšè—è¡¥å…¨ - å…¼å®¹API"""
        self.clear_ghost_text()
    
    def is_showing(self) -> bool:
        """æ˜¯å¦æ­£åœ¨æ˜¾ç¤ºè¡¥å…¨ - å…¼å®¹API"""
        return self.has_active_ghost_text()
    
    def handle_key_press(self, event: QKeyEvent) -> bool:
        """å¤„ç†æŒ‰é”®äº‹ä»¶ - å…¼å®¹API
        
        Args:
            event: æŒ‰é”®äº‹ä»¶
            
        Returns:
            bool: å¦‚æœäº‹ä»¶è¢«å¤„ç†åˆ™è¿”å›True
        """
        return self.event_handler.handle_key_press(event)
    
    def _calculate_incremental_completion(self, current_text: str, cursor_pos: int, suggestion: str) -> str:
        """è®¡ç®—å¢é‡è¡¥å…¨ - ä» ModernGhostTextCompletion è¿ç§»
        
        Args:
            current_text: å½“å‰æ–‡æœ¬
            cursor_pos: å…‰æ ‡ä½ç½®
            suggestion: AIå»ºè®®çš„å®Œæ•´æ–‡æœ¬
            
        Returns:
            str: å¢é‡è¡¥å…¨æ–‡æœ¬ï¼ˆåªåŒ…å«éœ€è¦æ’å…¥çš„éƒ¨åˆ†ï¼‰
        """
        if cursor_pos > len(current_text):
            return ""
            
        # è·å–å…‰æ ‡å‰çš„æ–‡æœ¬
        text_before_cursor = current_text[:cursor_pos]
        
        # å¯»æ‰¾å…¬å…±å‰ç¼€
        common_prefix_len = 0
        for i, char in enumerate(text_before_cursor):
            if i < len(suggestion) and char == suggestion[i]:
                common_prefix_len = i + 1
            else:
                break
                
        # å¦‚æœå»ºè®®æ–‡æœ¬ä»å…‰æ ‡ä½ç½®å¼€å§‹ï¼Œè¿”å›å®Œæ•´å»ºè®®
        if common_prefix_len == cursor_pos:
            return suggestion[cursor_pos:]
            
        # å¦åˆ™è¿”å›å»ºè®®ä¸­é™¤å»å…¬å…±å‰ç¼€çš„éƒ¨åˆ†
        if common_prefix_len > 0:
            return suggestion[common_prefix_len:]
            
        return suggestion

def integrate_with_text_editor(text_editor) -> DeepIntegratedGhostText:
    """å°†æ·±åº¦é›†æˆGhost Textç³»ç»Ÿé›†æˆåˆ°æ–‡æœ¬ç¼–è¾‘å™¨
    
    Args:
        text_editor: IntelligentTextEditorå®ä¾‹
        
    Returns:
        DeepIntegratedGhostText: é›†æˆåçš„Ghost Textç®¡ç†å™¨
    """
    ghost_text_manager = DeepIntegratedGhostText(text_editor)
    
    # ä¸å†æ›¿æ¢paintEventæ–¹æ³• - IntelligentTextEditorç±»è‡ªèº«çš„paintEventä¼šå¤„ç†Ghost Textæ¸²æŸ“
    # è¿™æ ·é¿å…äº†æ–¹æ³•æ›¿æ¢è¢«ç±»å®šä¹‰è¦†ç›–çš„é—®é¢˜
    logger.info(f"ğŸ”§ æ·±åº¦é›†æˆGhost Textå·²æ¿€æ´»ï¼ˆé€šè¿‡ç±»paintEventé›†æˆï¼‰")
    
    # ä¿å­˜åŸå§‹çš„keyPressEventæ–¹æ³•
    original_key_press_event = text_editor.keyPressEvent
    
    def enhanced_key_press_event(event: QKeyEvent):
        """å¢å¼ºçš„keyPressEventï¼Œé›†æˆGhost Textäº‹ä»¶å¤„ç†"""
        # å…ˆè®©Ghost Textå¤„ç†äº‹ä»¶
        if ghost_text_manager.event_handler.handle_key_press(event):
            return  # äº‹ä»¶å·²è¢«å¤„ç†
            
        # å¦åˆ™è°ƒç”¨åŸå§‹çš„äº‹ä»¶å¤„ç†
        original_key_press_event(event)
        
    # æ›¿æ¢keyPressEventæ–¹æ³•
    text_editor.keyPressEvent = enhanced_key_press_event
    
    logger.info("æ·±åº¦é›†æˆGhost Textç³»ç»Ÿå·²é›†æˆåˆ°æ–‡æœ¬ç¼–è¾‘å™¨")
    
    # ç¡®ä¿è¿”å›çš„å¯¹è±¡æœ‰æ•ˆ
    if ghost_text_manager is None:
        logger.error("ghost_text_manager is None before return!")
        raise ValueError("Failed to create DeepIntegratedGhostText instance")
    
    if not hasattr(ghost_text_manager, 'show_completion'):
        logger.error(f"ghost_text_manager missing show_completion method! Type: {type(ghost_text_manager)}")
        raise AttributeError("DeepIntegratedGhostText instance missing show_completion method")
    
    return ghost_text_manager